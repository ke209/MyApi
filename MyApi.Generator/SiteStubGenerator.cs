using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Nustache.Core;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;

namespace MyApi.Generator
{
    public class SiteStubGenerator
    {
        public SiteStubGenerator(string internalNamespace, Action<string> logWarning)
        {
            Log = logWarning;

            if (!string.IsNullOrWhiteSpace(internalNamespace))
            {
                InternalNamespace = $"{internalNamespace.Trim().TrimEnd('.')}.";
            }
        }

        public string InternalNamespace { get; }
        public Action<string> Log { get; }



        public string GenerateInterfaceStubs(string[] paths)
        {
            var trees = paths.Select(x => CSharpSyntaxTree.ParseText(File.ReadAllText(x))).ToList();

            var interfacesToGenerate = trees.SelectMany(FindInterfacesToGenerate).ToList();

            var templateInfo = GenerateTemplateInfoForInterfaceList(interfacesToGenerate);

            GenerateWarnings(interfacesToGenerate);

            Encoders.HtmlEncode = s => s;
            var text = Render.StringToString(ExtractTemplateSource(), templateInfo);
            return text;
        }

        public List<InterfaceDeclarationSyntax> FindInterfacesToGenerate(SyntaxTree tree)
        {
            var nodes = tree.GetRoot().DescendantNodes().ToList();
            if (nodes.OfType<UsingDirectiveSyntax>().All(u => u.Name.ToFullString() != "MyApi"))
                return new List<InterfaceDeclarationSyntax>();

            var list = nodes.OfType<InterfaceDeclarationSyntax>();
            var attibutes = list.SelectMany(s => s.AttributeLists.SelectMany(m => m.Attributes));
            if (attibutes.Any(a => a.Name.ToString().Contains("MyApiSite")))
                return list.ToList();
            else
                return new List<InterfaceDeclarationSyntax>();
        }

        public bool HasMyApiPropertyAttribute(PropertyDeclarationSyntax properties)
        {
            return true;
        }


        public TemplateInformation GenerateTemplateInfoForInterfaceList(List<InterfaceDeclarationSyntax> interfaceList)
        {
            interfaceList = interfaceList.OrderBy(i => i.Identifier.Text).ToList();

            var ret = new TemplateInformation
            {
                InternalNamespace = InternalNamespace ?? string.Empty,
                ClassList = interfaceList.Select(GenerateClassInfoForInterface).ToList(),
            };

            //AddInheritedMethods(ret.ClassList);
            //FixInheritedMethods(ret.ClassList);
            //MergePartialInterfaces(ret.ClassList);

            return ret;
        }

        public ClassTemplateInfo GenerateClassInfoForInterface(InterfaceDeclarationSyntax interfaceTree)
        {
            var ret = new ClassTemplateInfo();
            var parent = interfaceTree.Parent;
            while (parent != null && !(parent is NamespaceDeclarationSyntax)) parent = parent.Parent;

            ret.InterfaceName = GetInterfaceName(interfaceTree.Identifier);
            ret.GeneratedClassSuffix = ret.InterfaceName.Replace(".", "");
            ret.Modifiers = interfaceTree.Modifiers.Select(t => t.ValueText).FirstOrDefault(m => m == "public" || m == "internal");
            ret.BaseClasses = interfaceTree.BaseList?.Types.Select(b => b.GetSimpleName()).Where(b => b != null)
                .Select(t => new BaseClassInfo
                {
                    Name = t.Identifier.ValueText,
                    TypeParametersInfo = (t is GenericNameSyntax g ? g.TypeArgumentList.Arguments.Select(a => a.GetTypeInfo()).ToList() : null)
                }).ToList();

            var ns = parent as NamespaceDeclarationSyntax;
            ret.Namespace = ns?.Name?.ToString() ?? $"AutoGenerated{ret.GeneratedClassSuffix}";

            if (interfaceTree.TypeParameterList != null)
            {
                var typeParameters = interfaceTree.TypeParameterList.Parameters;
                if (typeParameters.Any())
                {
                    ret.TypeParametersInfo = typeParameters.Select(p => p.Identifier.ValueText).ToList();
                }

                ret.ConstraintClauses = interfaceTree.ConstraintClauses.ToFullString().Trim();
            }

            var rootNode = interfaceTree.Parent;
            while (rootNode.Parent != null) rootNode = rootNode.Parent;

            var usingsInsideNamespace = ns?.DescendantNodes()
                            .OfType<UsingDirectiveSyntax>()
                            .Select(x => $"{x.Alias} {x.StaticKeyword} {x.Name}".TrimStart())
                            ?? Enumerable.Empty<string>();

            var usingsOutsideNamespace = rootNode.DescendantNodes(x => !x.IsKind(SyntaxKind.NamespaceDeclaration))
                            .OfType<UsingDirectiveSyntax>()
                            .Select(x =>
                            {
                                // Globally qualify namespace name to avoid conflicts when put inside namespace.
                                var name = x.Name.ToString();
                                var globallyQualifiedName = name.Contains("::")
                                    ? name
                                    : "global::" + name;

                                return $"{x.Alias} {x.StaticKeyword} {globallyQualifiedName}".TrimStart();
                            });

            var usings = usingsInsideNamespace.Concat(usingsOutsideNamespace)
                            .Distinct()
                            .Where(x => x != "System" && x != "System.Net.Http" && x != "System.Collections.Generic" && x != "System.Linq")
                            .Select(x => new UsingDeclaration { Item = x });

            ret.UsingList = usings.ToList();

            ret.PropertyList = interfaceTree.Members
                                          .OfType<PropertyDeclarationSyntax>()
                                          .Select(x =>
                                          {
                                              var mti = new PropertyTemplateInfo
                                              {
                                                  Name = x.Identifier.Text,
                                                  InterfaceName = ret.InterfaceName,
                                                  TypeParametersInfo = ret.TypeParametersInfo?.ToList(),
                                                  ReturnTypeInfo = x.Type.GetTypeInfo(),
                                                  IsMyApiMethod = HasMyApiPropertyAttribute(x)
                                              };
                                              return mti;
                                          })
                                          .ToList();

            if (ret.BaseClasses?.Any(x => x.Name == nameof(IDisposable)) == true)
            {
                ret.MethodList.Add(new MethodTemplateInfo
                {
                    Name = nameof(IDisposable.Dispose),
                    ReturnTypeInfo = new TypeInfo { Name = "void" },
                    ArgumentListInfo = new List<ArgumentInfo>(),
                    IsMyApiMethod = false,
                    IsDispose = true,
                    InterfaceName = nameof(IDisposable),
                });
            }

            return ret;
        }


        string GetInterfaceName(SyntaxToken identifier)
        {
            if (identifier == null) return "";
            var interfaceParent = identifier.Parent != null ? identifier.Parent.Parent : identifier.Parent;

            if ((interfaceParent as ClassDeclarationSyntax) != null)
            {
                var classParent = (interfaceParent as ClassDeclarationSyntax).Identifier;
                return classParent + "." + identifier.ValueText;
            }

            return identifier.ValueText;
        }


        void AddInheritedMethods(List<ClassTemplateInfo> allClassList)
        {
            allClassList.ForEach(classInfo => AddInheritedMethods(allClassList, classInfo));
        }

        void AddInheritedMethods(List<ClassTemplateInfo> allClassList, ClassTemplateInfo classInfo)
        {
            classInfo.BaseClasses?.ForEach(baseClass =>
            {
                var baseClassInfo = allClassList.SingleOrDefault(oc => oc.InterfaceName == baseClass.Name &&
                    oc.TypeParametersInfo?.Count == baseClass.TypeParametersInfo?.Count);

                if (baseClassInfo == null)
                    return;

                AddInheritedMethods(allClassList, baseClassInfo);

                var methodsToAdd = baseClassInfo.MethodList
                    .Where(a => !classInfo.MethodList.Any(b => b.InterfaceName == a.InterfaceName &&
                        b.TypeParametersInfo?.Count == a.TypeParametersInfo?.Count && b.Name == a.Name))
                    .Select(a => new MethodTemplateInfo
                    {
                        ArgumentListInfo = a.ArgumentListInfo?
                            .Select(b => new ArgumentInfo { Name = b.Name, TypeInfo = b.TypeInfo.Clone() })
                            .ToList(),
                        IsMyApiMethod = a.IsMyApiMethod,
                        Name = a.Name,
                        ReturnTypeInfo = a.ReturnTypeInfo.Clone(),
                        MethodTypeParameterListInfo = a.MethodTypeParameterListInfo?.ToList(),
                        InterfaceName = a.InterfaceName,
                        TypeParametersInfo = a.TypeParametersInfo?.ToList(),
                    });

                classInfo.MethodList.AddRange(methodsToAdd);

                classInfo.UsingList = classInfo.UsingList.Union(baseClassInfo.UsingList).ToList();
            });
        }


        void FixInheritedMethods(List<ClassTemplateInfo> allClassList)
        {
            allClassList.ForEach(classInfo => FixInheritedMethods(allClassList, classInfo));
        }

        List<MethodTemplateInfo> FixInheritedMethods(List<ClassTemplateInfo> allClassList, ClassTemplateInfo rootClassInfo, ClassTemplateInfo classInfo = null)
        {
            List<MethodTemplateInfo> outResult = null;

            (classInfo ?? rootClassInfo).BaseClasses?.ForEach(baseClass =>
            {
                var baseClassInfo = allClassList.SingleOrDefault(oc => oc.InterfaceName == baseClass.Name &&
                    oc.TypeParametersInfo?.Count == baseClass.TypeParametersInfo?.Count);

                if (baseClassInfo == null)
                    return;

                var baseMethods = FixInheritedMethods(allClassList, rootClassInfo, baseClassInfo);

                var parametersMap = baseClassInfo.TypeParametersInfo?.Select((a, i) =>
                    {
                        var typeInfo = baseClass.TypeParametersInfo[i];
                        return a != typeInfo.ToString() ? new { Key = a, Value = typeInfo } : null;
                    }).Where(a => a != null).ToDictionary(a => a.Key, a => a.Value);

                void replaceGenericTypes(TypeInfo typeInfo)
                {
                    if (parametersMap?.Count > 0)
                    {
                        foreach (var itemMap in parametersMap)
                        {
                            if (typeInfo.Name == itemMap.Key)
                            {
                                typeInfo.Name = itemMap.Value.Name;
                                typeInfo.Children = itemMap.Value.Children?.Select(a => a.Clone()).ToList();
                            }
                            else if (typeInfo.Children != null)
                            {
                                foreach (var item in typeInfo.Children)
                                {
                                    replaceGenericTypes(item);
                                }
                            }
                        }
                    }
                }

                string replaceGenericType(string typeInfo)
                {
                    if (parametersMap?.Count > 0)
                    {
                        if (parametersMap.TryGetValue(typeInfo, out var result))
                            return result.ToString();
                    }

                    return typeInfo;
                }

                var methods = rootClassInfo.MethodList.Where(m => m.InterfaceName == baseClassInfo.InterfaceName &&
                    m.TypeParametersInfo?.Count == baseClassInfo.TypeParametersInfo?.Count).ToList();
                if (baseMethods != null)
                    methods.AddRange(baseMethods);

                foreach (var m in methods)
                {
                    if (m.ArgumentListInfo != null)
                        foreach (var a in m.ArgumentListInfo)
                        {
                            replaceGenericTypes(a.TypeInfo);
                        }
                    replaceGenericTypes(m.ReturnTypeInfo);
                    m.TypeParametersInfo = m.TypeParametersInfo?.Select(b => replaceGenericType(b)).ToList();
                }

                outResult = methods;
            });

            return outResult;
        }

        void MergePartialInterfaces(List<ClassTemplateInfo> classList)
        {
            var partialClasses = classList
                .GroupBy(c => c.Namespace + c.InterfaceName + string.Join(".", c.TypeParameters))
                .Where(g => g.Count() > 1)
                .ToList();

            foreach (var partialGroup in partialClasses)
            {
                var firstClass = partialGroup.First();

                foreach (var otherClass in partialGroup.Skip(1))
                {
                    firstClass.MethodList.AddRange(otherClass.MethodList);
                    classList.Remove(otherClass);
                }
            }
        }


        public void GenerateWarnings(List<InterfaceDeclarationSyntax> interfacesToGenerate)
        {
            var missingAttributeWarnings = interfacesToGenerate
                                           .SelectMany(i => i.Members.OfType<PropertyDeclarationSyntax>().Select(m => new
                                           {
                                               Interface = i,
                                               Property = m
                                           }))
                                           .Where(x => !HasMyApiPropertyAttribute(x.Property))
                                           .Select(x => new MissingMyApiSitePropertyAttributeWarning(x.Interface, x.Property));


            var diagnostics = missingAttributeWarnings;

            foreach (var diagnostic in diagnostics)
            {
                Log?.Invoke(diagnostic.ToString());
            }
        }


        public static string ExtractTemplateSource()
        {
            var ourPath = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "GeneratedSiteStubTemplate.mustache");

            // Try to return a flat file from the same directory, if it doesn't
            // exist, use the built-in resource version
            if (File.Exists(ourPath))
            {
                return File.ReadAllText(ourPath, Encoding.UTF8);
            }

            using (var src = typeof(SiteStubGenerator).Assembly.GetManifestResourceStream("MyApi.Generator.GeneratedSiteStubTemplate.mustache"))
            {
                var ms = new MemoryStream();
                src.CopyTo(ms);
                return Encoding.UTF8.GetString(ms.ToArray());
            }
        }

    }
}
