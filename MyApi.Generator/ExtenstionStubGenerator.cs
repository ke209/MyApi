using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Nustache.Core;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;

namespace MyApi.Generator
{
    public class ExtenstionStubGenerator
    {
        public ExtenstionStubGenerator(string internalNamespace, Action<string> logWarning)
        {
            Log = logWarning;

            if (!string.IsNullOrWhiteSpace(internalNamespace))
            {
                InternalNamespace = $"{internalNamespace.Trim().TrimEnd('.')}.";
            }
        }

        public string InternalNamespace { get; }
        public Action<string> Log { get; }


        public string GenerateInterfaceStubs(string[] paths)
        {
            var trees = paths.Select(x => CSharpSyntaxTree.ParseText(File.ReadAllText(x))).ToList();

            var interfacesToGenerate = trees.SelectMany( FindInterfacesToGenerate).ToList();

            var templateInfo = GenerateTemplateInfoForInterfaceList(interfacesToGenerate);

            GenerateWarnings(interfacesToGenerate);

            Encoders.HtmlEncode = s => s;
            var text = Render.StringToString(ExtractTemplateSource(), templateInfo);
            return text;
        }

        public List<InterfaceDeclarationSyntax> FindInterfacesToGenerate(SyntaxTree tree)
        {
            var nodes = tree.GetRoot().DescendantNodes().ToList();
            if (nodes.OfType<UsingDirectiveSyntax>().All(u => u.Name.ToFullString() != "MyApi"))
                return new List<InterfaceDeclarationSyntax>();

            var list = nodes.OfType<InterfaceDeclarationSyntax>();
            var attibutes = list.SelectMany(s => s.AttributeLists.SelectMany(m => m.Attributes));
            if (attibutes.Any(a => a.Name.ToString().Contains("ExtensionMyApi")))
                return list.ToList();
            else
                return new List<InterfaceDeclarationSyntax>();
        }

        public bool HasMyApiPropertyAttribute(PropertyDeclarationSyntax properties)
        {
            return true;
        }


        public TemplateInformation GenerateTemplateInfoForInterfaceList(List<InterfaceDeclarationSyntax> interfaceList)
        {
            interfaceList = interfaceList.OrderBy(i => i.Identifier.Text).ToList();

            var ret = new TemplateInformation
            {
                InternalNamespace = InternalNamespace ?? string.Empty,
                ClassList = new List<ClassTemplateInfo>()
            };

            foreach (var interfaceTree in interfaceList)
            {
                GenerateClassInfoForInterface(interfaceTree,ret.ClassList);
            }
            return ret;
        }

        
        public void GenerateClassInfoForInterface(InterfaceDeclarationSyntax interfaceTree,List<ClassTemplateInfo> classList)
        {
            ClassTemplateInfo classTemplateInfo = null;
            var extensionMyApiAttribute = interfaceTree.AttributeLists.SelectMany(r => r.Attributes)
                .FirstOrDefault(r => r.Name.ToString() == "ExtensionMyApi");
            if (extensionMyApiAttribute == null)
                throw new NotImplementedException("interface attribute is not Implemented ExtensionMyApi!");
            
            string typeFullName = extensionMyApiAttribute.ArgumentList.Arguments.FirstOrDefault().ToFullString().Replace("\"","");
            var extensionName = extensionMyApiAttribute.ArgumentList.Arguments.LastOrDefault().ToFullString().Replace("\"","");

            var index = typeFullName.LastIndexOf('.');
            var siteTypeName = typeFullName.Substring(index + 1);
            var siteNameSpace=typeFullName.Substring(0, index);


            classTemplateInfo = classList.FirstOrDefault(r => r.InterfaceName == siteTypeName);
            if (classTemplateInfo == null)
            {
                classTemplateInfo = new ClassTemplateInfo()
                {
                    InterfaceName = siteTypeName.ToString(),
                    GeneratedClassSuffix = siteTypeName.ToString(),
                    Namespace = siteNameSpace,
                    Modifiers = "public",
                    BaseClasses = null,
                    ExtensionList = new List<ExtensionTemplateInfo>(),
                    UsingList=new List<UsingDeclaration>() 
                };
                classList.Add(classTemplateInfo);
            }
            

            var parent = interfaceTree.Parent;
            while (parent != null && !(parent is NamespaceDeclarationSyntax)) parent = parent.Parent;
            var namespaceDeclarationSyntax = parent as NamespaceDeclarationSyntax;
            var item = namespaceDeclarationSyntax?.Name?.ToString() ??
                       $"AutoGenerated{classTemplateInfo.GeneratedClassSuffix}";

            if(classTemplateInfo.UsingList.All(a => a.Item != item))
            {
                classTemplateInfo.UsingList.Add(new UsingDeclaration()
                {
                    Item = item
                });
            };
            classTemplateInfo.ExtensionList.Add(new ExtensionTemplateInfo()
            {
                ReturnInterfaceType = GetInterfaceName(interfaceTree.Identifier),
                ExtensionName=extensionName,
                SiteType = siteTypeName
            });


        }

        string GetInterfaceName(SyntaxToken identifier)
        {
            if (identifier == null) return "";
            var interfaceParent = identifier.Parent != null ? identifier.Parent.Parent : identifier.Parent;

            if ((interfaceParent as ClassDeclarationSyntax) != null)
            {
                var classParent = (interfaceParent as ClassDeclarationSyntax).Identifier;
                return classParent + "." + identifier.ValueText;
            }

            return identifier.ValueText;
        }

        public void GenerateWarnings(List<InterfaceDeclarationSyntax> interfacesToGenerate)
        {
            var missingAttributeWarnings = interfacesToGenerate
                                           .SelectMany(i => i.Members.OfType<PropertyDeclarationSyntax>().Select(m => new
                                           {
                                               Interface = i,
                                               Property = m
                                           }))
                                           .Where(x => !HasMyApiPropertyAttribute(x.Property))
                                           .Select(x => new MissingMyApiSitePropertyAttributeWarning(x.Interface, x.Property));


            var diagnostics = missingAttributeWarnings;

            foreach (var diagnostic in diagnostics)
            {
                Log?.Invoke(diagnostic.ToString());
            }
        }


        public static string ExtractTemplateSource()
        {
            var ourPath = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "GeneratedExtensionStubTemplate.mustache.mustache");

            // Try to return a flat file from the same directory, if it doesn't
            // exist, use the built-in resource version
            if (File.Exists(ourPath))
            {
                return File.ReadAllText(ourPath, Encoding.UTF8);
            }

            using (var src = typeof(SiteStubGenerator).Assembly.GetManifestResourceStream("MyApi.Generator.GeneratedExtensionStubTemplate.mustache"))
            {
                var ms = new MemoryStream();
                src.CopyTo(ms);
                return Encoding.UTF8.GetString(ms.ToArray());
            }
        }

    }
}
